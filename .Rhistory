beside = TRUE, # puts bars beside one another. If false, they will overlap
names.arg = seq(65, 72, by = 1), # these need to match the defined bins
xlab = "Value",
ylab = "Count")
par(mfrow=c(1,1), mar=c(4, 4, 3, 2))
bins <- seq(65, 72, by = 1) # the groupings along x axis
hist(mean_heights_100, breaks = bins)$breaks
hist(mean_heights_1000, breaks = bins)$breaks
counts_100 <- hist(mean_heights_100, breaks = bins)$counts # the quantity of data that falls into that bin
counts_1000 <- hist(mean_heights_1000, breaks = bins)$counts
barplot(rbind(counts_100, counts_1000),
col = c("red", "blue"),
beside = TRUE, # puts bars beside one another. If false, they will overlap
names.arg = seq(65, 72, by = 1), # these need to match the defined bins
xlab = "Value",
ylab = "Count")
mean_heights_100 = numeric() # creates empty vector w/ infinite spaces for unknown values
for(i in 1:1000){
mean_heights_100 <- c(mean_heights_100, get_heights(100))
}
mean_heights_100
mean_heights_1000 = numeric()
for(i in 1:1000){
mean_heights_1000 <- c(mean_heights_1000, get_heights(100))
}
max(mean_heights_100)
min(mean_heights_100)
max(mean_heights_1000)
min(mean_heights_1000)
par(mfrow=c(1,1), mar=c(4, 4, 3, 2))
bins <- seq(65, 72, by = 1) # the groupings along x axis
hist(mean_heights_100, breaks = bins)$breaks
hist(mean_heights_1000, breaks = bins)$breaks
counts_100 <- hist(mean_heights_100, breaks = bins)$counts # the quantity of data that falls into that bin
counts_1000 <- hist(mean_heights_1000, breaks = bins)$counts
par(mfrow=c(1,1), mar=c(4, 4, 3, 2))
bins <- seq(64, 72, by = 1) # the groupings along x axis
hist(mean_heights_100, breaks = bins)$breaks
hist(mean_heights_1000, breaks = bins)$breaks
counts_100 <- hist(mean_heights_100, breaks = bins)$counts # the quantity of data that falls into that bin
counts_1000 <- hist(mean_heights_1000, breaks = bins)$counts
barplot(rbind(counts_100, counts_1000),
col = c("red", "blue"),
beside = TRUE, # puts bars beside one another. If false, they will overlap
names.arg = seq(64, 72, by = 1), # these need to match the defined bins
xlab = "Value",
ylab = "Count")
par(mfrow=c(1,1), mar=c(4, 4, 3, 2))
bins <- seq(64, 72, by = 0.5) # the groupings along x axis
# seq (min, max, by)
hist(mean_heights_100, breaks = bins)$breaks
hist(mean_heights_1000, breaks = bins)$breaks
counts_100 <- hist(mean_heights_100, breaks = bins)$counts # the quantity of data that falls into that bin
counts_1000 <- hist(mean_heights_1000, breaks = bins)$counts
barplot(rbind(counts_100, counts_1000),
col = c("red", "blue"),
beside = TRUE, # puts bars beside one another. If false, they will overlap
names.arg = seq(64, 72, by = 1), # these need to match the defined bins
xlab = "Value",
ylab = "Count")
par(mfrow=c(1,1), mar=c(4, 4, 3, 2))
bins <- seq(64, 72, by = 1) # the groupings along x axis
# seq (min, max, by)
hist(mean_heights_100, breaks = bins)$breaks
hist(mean_heights_1000, breaks = bins)$breaks
counts_100 <- hist(mean_heights_100, breaks = bins)$counts # the quantity of data that falls into that bin
counts_1000 <- hist(mean_heights_1000, breaks = bins)$counts
barplot(rbind(counts_100, counts_1000),
col = c("red", "blue"),
beside = TRUE, # puts bars beside one another. If false, they will overlap
names.arg = seq(64, 72, by = 1), # these need to match the defined bins
xlab = "Value",
ylab = "Count")
get_heights <- function(x) {
y <- rnorm(rsample, mean = 69, sd = 10)
mean.y <- mean(y)
return(mean.y)
}
mean_heights_100 = numeric() # creates empty vector w/ infinite spaces for unknown values
for(i in 1:1000){
mean_heights_100 <- c(mean_heights_100, get_heights(100))
}
get_heights <- function(x) {
y <- rnorm(x, mean = 69, sd = 10)
mean.y <- mean(y)
return(mean.y)
}
mean_heights_100 = numeric() # creates empty vector w/ infinite spaces for unknown values
for(i in 1:1000){
mean_heights_100 <- c(mean_heights_100, get_heights(100))
}
mean_heights_1000 = numeric()
for(i in 1:1000){
mean_heights_1000 <- c(mean_heights_1000, get_heights(100))
}
max(mean_heights_100)
min(mean_heights_100)
max(mean_heights_1000)
min(mean_heights_1000)
par(mfrow=c(1,1), mar=c(4, 4, 3, 2))
bins <- seq(64, 72, by = 1) # the groupings along x axis
# seq (min, max, by); the min should be 1 unit less than the actual min value (65)
# but R has an error when you do 1 unit above the actual max (72)
# Instead, for max, used 72 to avoid error and kept min as true min
hist(mean_heights_100, breaks = bins)$breaks
hist(mean_heights_1000, breaks = bins)$breaks
counts_100 <- hist(mean_heights_100, breaks = bins)$counts # the quantity of data that falls into that bin
counts_1000 <- hist(mean_heights_1000, breaks = bins)$counts
barplot(rbind(counts_100, counts_1000),
col = c("red", "blue"),
beside = TRUE, # puts bars beside one another. If false, they will overlap
names.arg = seq(64, 72, by = 1), # these need to match the defined bins
xlab = "Value",
ylab = "Count")
par(mfrow=c(1,1), mar=c(4, 4, 3, 2))
bins <- seq(65, 72, by = 1) # the groupings along x axis
# seq (min, max, by); the min should be 1 unit less than the actual min value (65)
# but R has an error when you do 1 unit above the actual max (72)
# Instead, for max, used 72 to avoid error and kept min as true min
hist(mean_heights_100, breaks = bins)$breaks
hist(mean_heights_1000, breaks = bins)$breaks
counts_100 <- hist(mean_heights_100, breaks = bins)$counts # the quantity of data that falls into that bin
counts_1000 <- hist(mean_heights_1000, breaks = bins)$counts
barplot(rbind(counts_100, counts_1000),
col = c("red", "blue"),
beside = TRUE, # puts bars beside one another. If false, they will overlap
names.arg = seq(65, 72, by = 1), # these need to match the defined bins
xlab = "Value",
ylab = "Count")
barplot(rbind(counts_100, counts_1000),
col = c("red", "blue"),
beside = TRUE, # puts bars beside one another. If false, they will overlap
names.arg = seq(65, 71, by = 1), # these need to match the defined bins
xlab = "Value",
ylab = "Count")
par(mfrow=c(1,1), mar=c(4, 4, 3, 2))
bins <- seq(65, 71, by = 1) # the groupings along x axis
# seq (min, max, by); the min should be 1 unit less than the actual min value (65)
# but R has an error when you do 1 unit above the actual max (72)
# Instead, for max, used 72 to avoid error and kept min as true min
hist(mean_heights_100, breaks = bins)$breaks
hist(mean_heights_1000, breaks = bins)$breaks
counts_100 <- hist(mean_heights_100, breaks = bins)$counts # the quantity of data that falls into that bin
counts_1000 <- hist(mean_heights_1000, breaks = bins)$counts
barplot(rbind(counts_100, counts_1000),
col = c("red", "blue"),
beside = TRUE, # puts bars beside one another. If false, they will overlap
names.arg = seq(65, 71, by = 1), # these need to match the defined bins
xlab = "Value",
ylab = "Count")
par(mfrow=c(1,1), mar=c(4, 4, 3, 2))
bins <- seq(65, 72, by = 1)
hist(mean_heights_100, breaks = bins)$breaks
hist(mean_heights_1000, breaks = bins)$breaks
counts_100 <- hist(mean_heights_100, breaks = bins)$counts # the quantity of data that falls into that bin
counts_1000 <- hist(mean_heights_1000, breaks = bins)$counts
par(mfrow=c(1,1), mar=c(4, 4, 3, 2))
bins <- seq(65, 73, by = 1) # the groupings along x axis
# seq (min, max, by); the min should be 1 unit less than the actual min value (65)
# but R has an error when you do 1 unit above the actual max (72)
# Instead, for max, used 72 to avoid error and kept min as true min
hist(mean_heights_100, breaks = bins)$breaks
hist(mean_heights_1000, breaks = bins)$breaks
counts_100 <- hist(mean_heights_100, breaks = bins)$counts # the quantity of data that falls into that bin
counts_1000 <- hist(mean_heights_1000, breaks = bins)$counts
barplot(rbind(counts_100, counts_1000),
col = c("red", "blue"),
beside = TRUE, # puts bars beside one another. If false, they will overlap
names.arg = seq(65, 72, by = 1), # these need to match the defined bins
xlab = "Value",
ylab = "Count")
mean_heights_1000 = numeric()
for(i in 1:1000){
mean_heights_1000 <- c(mean_heights_1000, get_heights(1000))
}
mean_heights_1000
max(mean_heights_100)
min(mean_heights_100)
max(mean_heights_1000)
min(mean_heights_1000)
par(mfrow=c(1,1), mar=c(4, 4, 3, 2))
bins <- seq(65, 72, by = 1) # the groupings along x axis
# seq (min, max, by); the min should be 1 unit less than the actual min value (65)
# but R has an error when you do 1 unit above the actual max (72)
# Instead, for max, used 72 to avoid error and kept min as true min
hist(mean_heights_100, breaks = bins)$breaks
hist(mean_heights_1000, breaks = bins)$breaks
counts_100 <- hist(mean_heights_100, breaks = bins)$counts # the quantity of data that falls into that bin
counts_1000 <- hist(mean_heights_1000, breaks = bins)$counts
barplot(rbind(counts_100, counts_1000),
col = c("red", "blue"),
beside = TRUE, # puts bars beside one another. If false, they will overlap
names.arg = seq(65, 72, by = 1), # these need to match the defined bins
xlab = "Value",
ylab = "Count")
par(mfrow=c(1,1), mar=c(4, 4, 3, 2))
bins <- seq(65, 72, by = 1)
hist(mean_heights_100, breaks = bins)$breaks
hist(mean_heights_1000, breaks = bins)$breaks
par(mfrow=c(1,1), mar=c(4, 4, 3, 2))
bins <- seq(65, 73, by = 1) # the groupings along x axis
# seq (min, max, by); the min should be 1 unit less than the actual min value (65)
# but R has an error when you do 1 unit above the actual max (72)
# Instead, for max, used 72 to avoid error and kept min as true min
hist(mean_heights_100, breaks = bins)$breaks
hist(mean_heights_1000, breaks = bins)$breaks
counts_100 <- hist(mean_heights_100, breaks = bins)$counts # the quantity of data that falls into that bin
counts_1000 <- hist(mean_heights_1000, breaks = bins)$counts
barplot(rbind(counts_100, counts_1000),
col = c("red", "blue"),
beside = TRUE, # puts bars beside one another. If false, they will overlap
names.arg = seq(65, 73, by = 1), # these need to match the defined bins
xlab = "Value",
ylab = "Count")
barplot(rbind(counts_100, counts_1000),
col = c("red", "blue"),
beside = TRUE, # puts bars beside one another. If false, they will overlap
names.arg = seq(65, 72, by = 1), # these need to match the defined bins
xlab = "Value",
ylab = "Count")
par(mfrow=c(1,1), mar=c(4, 4, 3, 2))
bins <- seq(65, 73, by = 0.5)
hist(mean_heights_100, breaks = bins)$breaks
hist(mean_heights_1000, breaks = bins)$breaks
counts_100 <- hist(mean_heights_100, breaks = bins)$counts # the quantity of data that falls into that bin
counts_1000 <- hist(mean_heights_1000, breaks = bins)$counts
barplot(rbind(counts_100, counts_1000),
col = c("red", "blue"),
beside = TRUE, # puts bars beside one another. If false, they will overlap
names.arg = seq(65, 72, by = 0.5), # these need to match the defined bins
xlab = "Value",
ylab = "Count")
barplot(rbind(counts_100, counts_1000),
col = c("red", "blue"),
beside = TRUE, # puts bars beside one another. If false, they will overlap
names.arg = seq(65, 72.5, by = 0.5), # these need to match the defined bins
xlab = "Value",
ylab = "Count")
legend(-15,0.4,c("n = 100","n = 1000"),lwd=4,col=c("red", "blue"),cex=1.5)
legend(65,400,c("n = 100","n = 1000"),lwd=4,col=c("red", "blue"),cex=1.5)
legend(0,400,c("n = 100","n = 1000"),lwd=4,col=c("red", "blue"),cex=1.5)
legend(0,400,c("n = 100","n = 1000"),lwd=4,col=c("red", "blue"),cex=1)
hist(mean_heights_100, breaks = bins)$breaks
hist(mean_heights_1000, breaks = bins)$breaks
counts_100 <- hist(mean_heights_100, breaks = bins)$counts # the quantity of data that falls into that bin
counts_1000 <- hist(mean_heights_1000, breaks = bins)$counts
barplot(rbind(counts_100, counts_1000),
col = c("red", "blue"),
beside = TRUE, # puts bars beside one another. If false, they will overlap
names.arg = seq(65, 72.5, by = 0.5), # these need to match the defined bins
xlab = "Value",
ylab = "Count")
legend(0,400,c("n = 100","n = 1000"),lwd=4,col=c("red", "blue"),cex=1)
barplot(rbind(counts_100, counts_1000),
col = c("red", "blue"),
beside = TRUE, # puts bars beside one another. If false, they will overlap
names.arg = seq(65, 72.5, by = 0.5), # these need to match the defined bins
xlab = "Average height (inches)",
ylab = "Count")
legend(0,400,c("n = 100","n = 1000"),lwd=4,col=c("red", "blue"),cex=1)
pdf(file="RBootcamp_Lohmueller_Barplot.pdf", width=6,height=6);
barplot(rbind(counts_100, counts_1000),
col = c("red", "blue"),
beside = TRUE, # puts bars beside one another. If false, they will overlap
names.arg = seq(65, 72.5, by = 0.5), # these need to match the defined bins
xlab = "Average height (inches)",
ylab = "Count")
legend(0,400,c("n = 100","n = 1000"),lwd=4,col=c("red", "blue"),cex=1)
# legend (x, y) for location on quadrant
# cex = size of legend box. May need to reset the hist code too
dev.off()
r <- 1.3
K <- 350
ttMax <- 10
n <- seq(0, 800, by = 10)
n
r <- seq(1, 3, by = 0.2) # growth rate vector from 1:3 with 0.2 increments
K <- seq(100, 500, by = 100) # carrying capacity vector from 100:500 in 100 increments
ttMax <- 10 # to run model over 10 years (no seq vector)
n <- 350 # population size (no seq vector)
data.vec <- rep(NA, 1, 50) # initialize empty vector with 1 row 50 col to store first 50 data values to be produced by model
for (ii in 1:length(data.vec)){ # ii refers to slot of value in 1:length(data.vec)
output <- discreteLogFunc(n, ttMax, r = r[ii], K = K[ii], PLOTFLAG = 0) # output for discrete logistic func at constant n and ttMax, but changing r and K parameters
data.vec[ii] <- output[ttMax] # store values collected from model based on the changing r and K parameters at ttMax = 10
}
discreteLogFunc <- function(n, ttMax, r, K)
for (ii in 1:length(data.vec)){ # ii refers to slot of value in 1:length(data.vec)
output <- discreteLogFunc(n, ttMax, r = r[ii], K = K[ii], PLOTFLAG = 0) # output for discrete logistic func at constant n and ttMax, but changing r and K parameters
data.vec[ii] <- output[ttMax] # store values collected from model based on the changing r and K parameters at ttMax = 10
}
plot(rbind(r, k), data.vec,
col = c("red", "seafoam green")
xlab = "x axis",
ylab = "y axis")
plot(rbind(r, k), data.vec,
col = c("red", "green"),
xlab = "x axis",
ylab = "y axis")
plot(rbind(r, K), data.vec,
col = c("red", "green"),
xlab = "x axis",
ylab = "y axis")
plot(data.vec, rbind(r, K),
col = c("red", "green"),
xlab = "x axis",
ylab = "y axis")
plot(r, data.vec,
col = c("red", "green"),
xlab = "x axis",
ylab = "y axis")
plot(r, K,
col = c("red", "green"),
xlab = "x axis",
ylab = "y axis")
for (ii in 1:length(data.vec)){ # ii refers to slot of a value in 1:lengt(data.vec) vector
output <- discreteLogFunc(n, ttMax, r = r[ii], K = K[ii]) # output for discrete logistic func at constant n and ttMax, but changing r and K parameters
data.vec[ii] <- output[ttMax] # store values collected from model based on the changing r and K parameters at ttMax = 10
}
for (ii in 1:length(data.vec)){ # ii refers to slot of a value in 1:lengt(data.vec) vector
output <- discreteLogFunc(n, ttMax, r = r[ii], K = K[ii], PLOTFLAG = 0) # output for discrete logistic func at constant n and ttMax, but changing r and K parameters
data.vec[ii] <- output[ttMax] # store values collected from model based on the changing r and K parameters at ttMax = 10
}
for (ii in 1:length(data.vec)){ # ii refers to slot of a value in 1:lengt(data.vec) vector
output <- discreteLogFunc(n, ttMax, r = r[ii], K = K[ii], PLOTFLAG = 0){ # output for discrete logistic func at constant n and ttMax, but changing r and K parameters
data.vec[ii] <- output[ttMax]
}# store values collected from model based on the changing r and K parameters at ttMax = 10
}
data.vec[ii] <- output[ttMax]} # store values collected from model based on the changing r and K parameters at ttMax = 10
for (ii in 1:length(data.vec)){ # ii refers to slot of a value in 1:lengt(data.vec) vector
output <- discreteLogFunc(n, ttMax, r = r[ii], K = K[ii], PLOTFLAG = 0), # output for discrete logistic func at constant n and ttMax, but changing r and K parameters
data.vec[ii] <- output[ttMax] # store values collected from model based on the changing r and K parameters at ttMax = 10
}
for (ii in 1:length(data.vec)){ # ii refers to slot of a value in 1:lengt(data.vec) vector
output <- discreteLogFunc(n, ttMax, r = r[ii], K = K[ii], PLOTFLAG = 0){ # output for discrete logistic func at constant n and ttMax, but changing r and K parameters
data.vec[ii] <- output[ttMax]} # store values collected from model based on the changing r and K parameters at ttMax = 10
}
for (ii in 1:length(data.vec)){ # ii refers to slot of a value in 1:lengt(data.vec) vector
output <- discreteLogFunc(n, ttMax, r = r[ii], K = K[ii], PLOTFLAG = 0){ # output for discrete logistic func at constant n and ttMax, but changing r and K parameters
data.vec[ii] <- output[ttMax]# store values collected from model based on the changing r and K parameters at ttMax = 10
}
}
for (ii in 1:length(data.vec)){ # ii refers to slot of a value in 1:lengt(data.vec) vector
output <- discreteLogFunc(n, ttMax, r = r[ii], K = K[ii], PLOTFLAG = 0){ # output for discrete logistic func at constant n and ttMax, but changing r and K parameters
data.vec[ii] <- output[ttMax]# store values collected from model based on the changing r and K parameters at ttMax = 10
}
}
for (ii in 1:length(data.vec)){ # ii refers to slot of a value in 1:lengt(data.vec) vector
output <- discreteLogFunc(n, ttMax, r = r[ii], K = K[ii], PLOTFLAG = 0) # output for discrete logistic func at constant n and ttMax, but changing r and K parameters
data.vec[ii] <- output[ttMax]# store values collected from model based on the changing r and K parameters at ttMax = 10
}
for (ii in 1:length(data.vec)){ # ii refers to slot of a value in 1:lengt(data.vec) vector
output <- discreteLogFunc(n, ttMax, r = r[ii], K = K[ii], PLOTFLAG = 1) # output for discrete logistic func at constant n and ttMax, but changing r and K parameters
data.vec[ii] <- output[ttMax]# store values collected from model based on the changing r and K parameters at ttMax = 10
}
output <- discreteLogFunc(n, ttMax, r = r[ii], K = K[ii], PLOTFLAG = 9) # output for discrete logistic func at constant n and ttMax, but changing r and K parameters
data.vec[ii] <- output[ttMax]# store values collected from model based on the changing r and K parameters at ttMax = 10
for (ii in 1:length(data.vec)){ # ii refers to slot of a value in 1:lengt(data.vec) vector
output <- discreteLogFunc(n, ttMax, r = r[ii], K = K[ii], PLOTFLAG = 9) # output for discrete logistic func at constant n and ttMax, but changing r and K parameters
data.vec[ii] <- output[ttMax]# store values collected from model based on the changing r and K parameters at ttMax = 10
}
for (ii in 1:length(data.vec)){ # ii refers to slot of a value in 1:lengt(data.vec) vector
output <- discreteLogFunc(n, ttMax, r = r[ii], K = K[ii], PLOTFLAG = TRUE) # output for discrete logistic func at constant n and ttMax, but changing r and K parameters
data.vec[ii] <- output[ttMax]# store values collected from model based on the changing r and K parameters at ttMax = 10
}
plot(r, K,
col = c("red", "green"),
xlab = "x axis",
ylab = "y axis")
for (ii in 1:length(data.vec)){ # ii refers to slot of a value in 1:lengt(data.vec) vector
output <- discreteLogFunc(n, ttMax, r = r[ii], K = K[ii], PLOTFLAG = TRUE) # output for discrete logistic func at constant n and ttMax, but changing r and K parameters
data.vec[ii] <- output[ttMax] # store values collected from model based on the changing r and K parameters at ttMax = 10
plot(rbind(r, K), data.vec,
col = c("red", "green"),
xlab = "x axis",
ylab = "y axis")
}
for (ii in 1:length(data.vec)){ # ii refers to slot of a value in 1:lengt(data.vec) vector
output <- discreteLogFunc(n, ttMax, r = r[ii], K = K[ii], PLOTFLAG = TRUE) # output for discrete logistic func at constant n and ttMax, but changing r and K parameters
data.vec[ii] <- output[ttMax] # store values collected from model based on the changing r and K parameters at ttMax = 10
plot(rbind(r, K), data.vec,
col = c("red", "green"),
xlab = "x axis",
ylab = "y axis")
return(data.vec)
}
getwd()
setwd("~/Box Sync/RBootcamp/RBootcamp")
getwd()
setwd("/Users/BenjaminHa/Box Sync/RBootcamp/RBootcamp")
getwd()
snpsDataFrame=read.table('hapmap_CEU_r23a_chr2_ld-2.txt', header=TRUE)
dim(snpsDataFrame)
head(snpsDataFrame)
names(snpsDataFrame)
row.names(snpsDataFrame)
phenoDataFrame=read.table('pheno.sim.2014-2.txt', header=TRUE)
head(phenoDataFrame)
dim(phenoDataFrame)
names(phenoDataFrame)
?chisq.test()
names(snpsDataFrame)
head(snpsDataFrame)
?row()
?col()
snps.col <- snpsDataFrame[, 60]
snps.col
?chisq.test()
names(snpsDataFrame)
snps.col
snps.col <- snpsDataFrame[, 60]
snps.names <- names(snpsDataFrame)
snps.names
?chisq.test(snps.names, snps.col)
chisq.test(snps.names, snps.col)
head((snpsDataFrame))
snps.col <- snpsDataFrame[60,]
chisq.test(snps.names, snps.col)
snps=as.matrix(snpsDataFrame)
snps
compute_chisquare=function(x){
freq=sum(x,na.rm=TRUE)/(2.0*sum(!is.na(x)))
cnt0=sum(x==0,na.rm=TRUE)
cnt1=sum(x==1,na.rm=TRUE)
cnt2=sum(x==2,na.rm=TRUE)
obscnts=c(cnt0,cnt1,cnt2)
#print(obscnts)
n=sum(obscnts)
expcnts=c((1-freq)^2,2*freq*(1-freq),freq^2)*n
chisq=sum((obscnts-expcnts)^2/expcnts)
return(chisq)
}
compute_chisquare_2=function(x){
freq=sum(x,na.rm=TRUE)/(2.0*sum(!is.na(x)))
cnt0=sum(x==0,na.rm=TRUE)
cnt1=sum(x==1,na.rm=TRUE)
cnt2=sum(x==2,na.rm=TRUE)
obscnts=c(cnt0,cnt1,cnt2)
#print(obscnts)
n=sum(obscnts)
#here we use the built-in function for the chi-sq distribution:
exp_probs=c((1-freq)^2,2*freq*(1-freq),freq^2) #note, here we don't multiply by n
chisq<-chisq.test(obscnts,p=exp_probs, correct = FALSE)$statistic
return(chisq)
}
chisqs=apply(snps,1,compute_chisquare)
chisqs2=apply(snps,1,compute_chisquare_2)
setwd("/Users/BenjaminHa/Box Sync/RBootcamp/RBootcamp")
snpsDataFrame=read.table('hapmap_CEU_r23a_chr2_ld-2.txt', header=TRUE) # load data
phenoDataFrame=read.table('pheno.sim.2014-2.txt', header=TRUE) # load data
snps=as.matrix(snpsDataFrame) # convert dataframe into a matrix
head((snpsDataFrame))
snps.col <- snpsDataFrame[60,]
compute_chisquare=function(x){
freq=sum(x,na.rm=TRUE)/(2.0*sum(!is.na(x)))
cnt0=sum(x==0,na.rm=TRUE)
cnt1=sum(x==1,na.rm=TRUE)
cnt2=sum(x==2,na.rm=TRUE)
obscnts=c(cnt0,cnt1,cnt2)
#print(obscnts)
n=sum(obscnts)
expcnts=c((1-freq)^2,2*freq*(1-freq),freq^2)*n
chisq=sum((obscnts-expcnts)^2/expcnts)
return(chisq)
}
compute_chisquare_2=function(x){
freq=sum(x,na.rm=TRUE)/(2.0*sum(!is.na(x)))
cnt0=sum(x==0,na.rm=TRUE)
cnt1=sum(x==1,na.rm=TRUE)
cnt2=sum(x==2,na.rm=TRUE)
obscnts=c(cnt0,cnt1,cnt2)
#print(obscnts)
n=sum(obscnts)
#here we use the built-in function for the chi-sq distribution:
exp_probs=c((1-freq)^2,2*freq*(1-freq),freq^2) #note, here we don't multiply by n
chisq<-chisq.test(obscnts,p=exp_probs, correct = FALSE)$statistic
return(chisq)
}
chisqs=apply(snps,1,compute_chisquare)
chisqs2=apply(snps,1,compute_chisquare_2)
chisqs=apply(snps,1,compute_chisquare)
chisqs2 = apply(snps, 1, compute_chisquare_2)
cor.test(chisqs,chisqs2)
plot(chisqs,chisqs2)
?chisq.test()
?chisq.test(snps,
y = NULL,
correct = TRUE,
p = rep(1/length(x),length(x)),
rescale.p = FALSE,
simulate.p.value = FALSE,
B = 2000))
?chisq.test(snps,
y = NULL,
correct = TRUE,
p = rep(1/length(x),length(x)),
rescale.p = FALSE,
simulate.p.value = FALSE,
B = 2000)
chisq.test(snps,
y = NULL,
correct = TRUE,
p = rep(1/length(x),length(x)),
rescale.p = FALSE,
simulate.p.value = FALSE,
B = 2000)
chisq.test(x = snps,
y = NULL,
correct = TRUE,
p = rep(1/length(x),length(x)),
rescale.p = FALSE,
simulate.p.value = FALSE,
B = 2000)
