for(i in 1:1000){
mean_heights_1000 <- c(mean_heights_1000, get_heights(100))
}
max(mean_heights_100)
min(mean_heights_100)
max(mean_heights_1000)
min(mean_heights_1000)
mean_heights_100 = numeric() # creates empty vector with infinite spaces for unknown values
for(i in 1:1000){
mean_heights_100 <- c(mean_heights_100, get_heights(100))
}
mean_heights_1000 = numeric()
for(i in 1:1000){
mean_heights_1000 <- c(mean_heights_1000, get_heights(100))
}
max(mean_heights_100)
min(mean_heights_100)
max(mean_heights_1000)
min(mean_heights_1000)
hist(mean_heights_100, breaks = bins)$breaks
hist(mean_heights_1000, breaks = bins)$breaks
par(mfrow=c(1,1), mar=c(4, 4, 3, 2))
bins <- seq(64, 73, by = 1)
hist(mean_heights_100, breaks = bins)$breaks
hist(mean_heights_1000, breaks = bins)$breaks
counts_100 <- hist(mean_heights_100, breaks = bins)$counts # the quantity of data that falls into that bin
counts_1000 <- hist(mean_heights_1000, breaks = bins)$counts
barplot(rbind(counts_100, counts_1000),
col = c("red", "blue"),
beside = TRUE, # puts bars beside one another. If false, they will overlap
names.arg = seq(64, 73, by = 1), # these need to match the defined bins
xlab = "Value",
ylab = "Count")
barplot(rbind(counts_100, counts_1000),
col = c("red", "blue"),
beside = TRUE, # puts bars beside one another. If false, they will overlap
names.arg = seq(64, 72, by = 1), # these need to match the defined bins
xlab = "Value",
ylab = "Count")
barplot(rbind(counts_100, counts_1000),
col = c("red", "blue"),
beside = TRUE, # puts bars beside one another. If false, they will overlap
names.arg = seq(65, 72, by = 1), # these need to match the defined bins
xlab = "Value",
ylab = "Count")
par(mfrow=c(1,1), mar=c(4, 4, 3, 2))
bins <- seq(65, 72, by = 1) # the groupings along x axis
hist(mean_heights_100, breaks = bins)$breaks
hist(mean_heights_1000, breaks = bins)$breaks
counts_100 <- hist(mean_heights_100, breaks = bins)$counts # the quantity of data that falls into that bin
counts_1000 <- hist(mean_heights_1000, breaks = bins)$counts
barplot(rbind(counts_100, counts_1000),
col = c("red", "blue"),
beside = TRUE, # puts bars beside one another. If false, they will overlap
names.arg = seq(65, 72, by = 1), # these need to match the defined bins
xlab = "Value",
ylab = "Count")
mean_heights_100 = numeric() # creates empty vector w/ infinite spaces for unknown values
for(i in 1:1000){
mean_heights_100 <- c(mean_heights_100, get_heights(100))
}
mean_heights_100
mean_heights_1000 = numeric()
for(i in 1:1000){
mean_heights_1000 <- c(mean_heights_1000, get_heights(100))
}
max(mean_heights_100)
min(mean_heights_100)
max(mean_heights_1000)
min(mean_heights_1000)
par(mfrow=c(1,1), mar=c(4, 4, 3, 2))
bins <- seq(65, 72, by = 1) # the groupings along x axis
hist(mean_heights_100, breaks = bins)$breaks
hist(mean_heights_1000, breaks = bins)$breaks
counts_100 <- hist(mean_heights_100, breaks = bins)$counts # the quantity of data that falls into that bin
counts_1000 <- hist(mean_heights_1000, breaks = bins)$counts
par(mfrow=c(1,1), mar=c(4, 4, 3, 2))
bins <- seq(64, 72, by = 1) # the groupings along x axis
hist(mean_heights_100, breaks = bins)$breaks
hist(mean_heights_1000, breaks = bins)$breaks
counts_100 <- hist(mean_heights_100, breaks = bins)$counts # the quantity of data that falls into that bin
counts_1000 <- hist(mean_heights_1000, breaks = bins)$counts
barplot(rbind(counts_100, counts_1000),
col = c("red", "blue"),
beside = TRUE, # puts bars beside one another. If false, they will overlap
names.arg = seq(64, 72, by = 1), # these need to match the defined bins
xlab = "Value",
ylab = "Count")
par(mfrow=c(1,1), mar=c(4, 4, 3, 2))
bins <- seq(64, 72, by = 0.5) # the groupings along x axis
# seq (min, max, by)
hist(mean_heights_100, breaks = bins)$breaks
hist(mean_heights_1000, breaks = bins)$breaks
counts_100 <- hist(mean_heights_100, breaks = bins)$counts # the quantity of data that falls into that bin
counts_1000 <- hist(mean_heights_1000, breaks = bins)$counts
barplot(rbind(counts_100, counts_1000),
col = c("red", "blue"),
beside = TRUE, # puts bars beside one another. If false, they will overlap
names.arg = seq(64, 72, by = 1), # these need to match the defined bins
xlab = "Value",
ylab = "Count")
par(mfrow=c(1,1), mar=c(4, 4, 3, 2))
bins <- seq(64, 72, by = 1) # the groupings along x axis
# seq (min, max, by)
hist(mean_heights_100, breaks = bins)$breaks
hist(mean_heights_1000, breaks = bins)$breaks
counts_100 <- hist(mean_heights_100, breaks = bins)$counts # the quantity of data that falls into that bin
counts_1000 <- hist(mean_heights_1000, breaks = bins)$counts
barplot(rbind(counts_100, counts_1000),
col = c("red", "blue"),
beside = TRUE, # puts bars beside one another. If false, they will overlap
names.arg = seq(64, 72, by = 1), # these need to match the defined bins
xlab = "Value",
ylab = "Count")
get_heights <- function(x) {
y <- rnorm(rsample, mean = 69, sd = 10)
mean.y <- mean(y)
return(mean.y)
}
mean_heights_100 = numeric() # creates empty vector w/ infinite spaces for unknown values
for(i in 1:1000){
mean_heights_100 <- c(mean_heights_100, get_heights(100))
}
get_heights <- function(x) {
y <- rnorm(x, mean = 69, sd = 10)
mean.y <- mean(y)
return(mean.y)
}
mean_heights_100 = numeric() # creates empty vector w/ infinite spaces for unknown values
for(i in 1:1000){
mean_heights_100 <- c(mean_heights_100, get_heights(100))
}
mean_heights_1000 = numeric()
for(i in 1:1000){
mean_heights_1000 <- c(mean_heights_1000, get_heights(100))
}
max(mean_heights_100)
min(mean_heights_100)
max(mean_heights_1000)
min(mean_heights_1000)
par(mfrow=c(1,1), mar=c(4, 4, 3, 2))
bins <- seq(64, 72, by = 1) # the groupings along x axis
# seq (min, max, by); the min should be 1 unit less than the actual min value (65)
# but R has an error when you do 1 unit above the actual max (72)
# Instead, for max, used 72 to avoid error and kept min as true min
hist(mean_heights_100, breaks = bins)$breaks
hist(mean_heights_1000, breaks = bins)$breaks
counts_100 <- hist(mean_heights_100, breaks = bins)$counts # the quantity of data that falls into that bin
counts_1000 <- hist(mean_heights_1000, breaks = bins)$counts
barplot(rbind(counts_100, counts_1000),
col = c("red", "blue"),
beside = TRUE, # puts bars beside one another. If false, they will overlap
names.arg = seq(64, 72, by = 1), # these need to match the defined bins
xlab = "Value",
ylab = "Count")
par(mfrow=c(1,1), mar=c(4, 4, 3, 2))
bins <- seq(65, 72, by = 1) # the groupings along x axis
# seq (min, max, by); the min should be 1 unit less than the actual min value (65)
# but R has an error when you do 1 unit above the actual max (72)
# Instead, for max, used 72 to avoid error and kept min as true min
hist(mean_heights_100, breaks = bins)$breaks
hist(mean_heights_1000, breaks = bins)$breaks
counts_100 <- hist(mean_heights_100, breaks = bins)$counts # the quantity of data that falls into that bin
counts_1000 <- hist(mean_heights_1000, breaks = bins)$counts
barplot(rbind(counts_100, counts_1000),
col = c("red", "blue"),
beside = TRUE, # puts bars beside one another. If false, they will overlap
names.arg = seq(65, 72, by = 1), # these need to match the defined bins
xlab = "Value",
ylab = "Count")
barplot(rbind(counts_100, counts_1000),
col = c("red", "blue"),
beside = TRUE, # puts bars beside one another. If false, they will overlap
names.arg = seq(65, 71, by = 1), # these need to match the defined bins
xlab = "Value",
ylab = "Count")
par(mfrow=c(1,1), mar=c(4, 4, 3, 2))
bins <- seq(65, 71, by = 1) # the groupings along x axis
# seq (min, max, by); the min should be 1 unit less than the actual min value (65)
# but R has an error when you do 1 unit above the actual max (72)
# Instead, for max, used 72 to avoid error and kept min as true min
hist(mean_heights_100, breaks = bins)$breaks
hist(mean_heights_1000, breaks = bins)$breaks
counts_100 <- hist(mean_heights_100, breaks = bins)$counts # the quantity of data that falls into that bin
counts_1000 <- hist(mean_heights_1000, breaks = bins)$counts
barplot(rbind(counts_100, counts_1000),
col = c("red", "blue"),
beside = TRUE, # puts bars beside one another. If false, they will overlap
names.arg = seq(65, 71, by = 1), # these need to match the defined bins
xlab = "Value",
ylab = "Count")
par(mfrow=c(1,1), mar=c(4, 4, 3, 2))
bins <- seq(65, 72, by = 1)
hist(mean_heights_100, breaks = bins)$breaks
hist(mean_heights_1000, breaks = bins)$breaks
counts_100 <- hist(mean_heights_100, breaks = bins)$counts # the quantity of data that falls into that bin
counts_1000 <- hist(mean_heights_1000, breaks = bins)$counts
par(mfrow=c(1,1), mar=c(4, 4, 3, 2))
bins <- seq(65, 73, by = 1) # the groupings along x axis
# seq (min, max, by); the min should be 1 unit less than the actual min value (65)
# but R has an error when you do 1 unit above the actual max (72)
# Instead, for max, used 72 to avoid error and kept min as true min
hist(mean_heights_100, breaks = bins)$breaks
hist(mean_heights_1000, breaks = bins)$breaks
counts_100 <- hist(mean_heights_100, breaks = bins)$counts # the quantity of data that falls into that bin
counts_1000 <- hist(mean_heights_1000, breaks = bins)$counts
barplot(rbind(counts_100, counts_1000),
col = c("red", "blue"),
beside = TRUE, # puts bars beside one another. If false, they will overlap
names.arg = seq(65, 72, by = 1), # these need to match the defined bins
xlab = "Value",
ylab = "Count")
mean_heights_1000 = numeric()
for(i in 1:1000){
mean_heights_1000 <- c(mean_heights_1000, get_heights(1000))
}
mean_heights_1000
max(mean_heights_100)
min(mean_heights_100)
max(mean_heights_1000)
min(mean_heights_1000)
par(mfrow=c(1,1), mar=c(4, 4, 3, 2))
bins <- seq(65, 72, by = 1) # the groupings along x axis
# seq (min, max, by); the min should be 1 unit less than the actual min value (65)
# but R has an error when you do 1 unit above the actual max (72)
# Instead, for max, used 72 to avoid error and kept min as true min
hist(mean_heights_100, breaks = bins)$breaks
hist(mean_heights_1000, breaks = bins)$breaks
counts_100 <- hist(mean_heights_100, breaks = bins)$counts # the quantity of data that falls into that bin
counts_1000 <- hist(mean_heights_1000, breaks = bins)$counts
barplot(rbind(counts_100, counts_1000),
col = c("red", "blue"),
beside = TRUE, # puts bars beside one another. If false, they will overlap
names.arg = seq(65, 72, by = 1), # these need to match the defined bins
xlab = "Value",
ylab = "Count")
par(mfrow=c(1,1), mar=c(4, 4, 3, 2))
bins <- seq(65, 72, by = 1)
hist(mean_heights_100, breaks = bins)$breaks
hist(mean_heights_1000, breaks = bins)$breaks
par(mfrow=c(1,1), mar=c(4, 4, 3, 2))
bins <- seq(65, 73, by = 1) # the groupings along x axis
# seq (min, max, by); the min should be 1 unit less than the actual min value (65)
# but R has an error when you do 1 unit above the actual max (72)
# Instead, for max, used 72 to avoid error and kept min as true min
hist(mean_heights_100, breaks = bins)$breaks
hist(mean_heights_1000, breaks = bins)$breaks
counts_100 <- hist(mean_heights_100, breaks = bins)$counts # the quantity of data that falls into that bin
counts_1000 <- hist(mean_heights_1000, breaks = bins)$counts
barplot(rbind(counts_100, counts_1000),
col = c("red", "blue"),
beside = TRUE, # puts bars beside one another. If false, they will overlap
names.arg = seq(65, 73, by = 1), # these need to match the defined bins
xlab = "Value",
ylab = "Count")
barplot(rbind(counts_100, counts_1000),
col = c("red", "blue"),
beside = TRUE, # puts bars beside one another. If false, they will overlap
names.arg = seq(65, 72, by = 1), # these need to match the defined bins
xlab = "Value",
ylab = "Count")
par(mfrow=c(1,1), mar=c(4, 4, 3, 2))
bins <- seq(65, 73, by = 0.5)
hist(mean_heights_100, breaks = bins)$breaks
hist(mean_heights_1000, breaks = bins)$breaks
counts_100 <- hist(mean_heights_100, breaks = bins)$counts # the quantity of data that falls into that bin
counts_1000 <- hist(mean_heights_1000, breaks = bins)$counts
barplot(rbind(counts_100, counts_1000),
col = c("red", "blue"),
beside = TRUE, # puts bars beside one another. If false, they will overlap
names.arg = seq(65, 72, by = 0.5), # these need to match the defined bins
xlab = "Value",
ylab = "Count")
barplot(rbind(counts_100, counts_1000),
col = c("red", "blue"),
beside = TRUE, # puts bars beside one another. If false, they will overlap
names.arg = seq(65, 72.5, by = 0.5), # these need to match the defined bins
xlab = "Value",
ylab = "Count")
legend(-15,0.4,c("n = 100","n = 1000"),lwd=4,col=c("red", "blue"),cex=1.5)
legend(65,400,c("n = 100","n = 1000"),lwd=4,col=c("red", "blue"),cex=1.5)
legend(0,400,c("n = 100","n = 1000"),lwd=4,col=c("red", "blue"),cex=1.5)
legend(0,400,c("n = 100","n = 1000"),lwd=4,col=c("red", "blue"),cex=1)
hist(mean_heights_100, breaks = bins)$breaks
hist(mean_heights_1000, breaks = bins)$breaks
counts_100 <- hist(mean_heights_100, breaks = bins)$counts # the quantity of data that falls into that bin
counts_1000 <- hist(mean_heights_1000, breaks = bins)$counts
barplot(rbind(counts_100, counts_1000),
col = c("red", "blue"),
beside = TRUE, # puts bars beside one another. If false, they will overlap
names.arg = seq(65, 72.5, by = 0.5), # these need to match the defined bins
xlab = "Value",
ylab = "Count")
legend(0,400,c("n = 100","n = 1000"),lwd=4,col=c("red", "blue"),cex=1)
barplot(rbind(counts_100, counts_1000),
col = c("red", "blue"),
beside = TRUE, # puts bars beside one another. If false, they will overlap
names.arg = seq(65, 72.5, by = 0.5), # these need to match the defined bins
xlab = "Average height (inches)",
ylab = "Count")
legend(0,400,c("n = 100","n = 1000"),lwd=4,col=c("red", "blue"),cex=1)
pdf(file="RBootcamp_Lohmueller_Barplot.pdf", width=6,height=6);
barplot(rbind(counts_100, counts_1000),
col = c("red", "blue"),
beside = TRUE, # puts bars beside one another. If false, they will overlap
names.arg = seq(65, 72.5, by = 0.5), # these need to match the defined bins
xlab = "Average height (inches)",
ylab = "Count")
legend(0,400,c("n = 100","n = 1000"),lwd=4,col=c("red", "blue"),cex=1)
# legend (x, y) for location on quadrant
# cex = size of legend box. May need to reset the hist code too
dev.off()
length(r)
r <- seq(1, 3, by = 0.2) # growth rate vector from 1:3 with 0.2 increments
length(r)
K <- seq(100, 500, by = 100) # carrying capacity vector from 100:500 in 100 increments
length(K)
ttMax <- 10 # to run model over constant time 10 years
n <- 350 # constant population size 350
data.vec <- matrix(NA, nrow=length(K), ncol=length(r)) # initialize empty vector with 5 row 11 col to store data
discreteLogFunc <- function(n, ttMax, r, K)
discreteLogFunc <- function(n, ttMax, r, K){}
rickerFun <- function(r, n, ttMax, K){
NN <- rep(NA, ttMax + 1)
NN[1] <- n
for(tt in 1:ttMax){
NN[tt + 1] <- NN[tt]*exp(r*(1 - (NN[tt]/K))) # Note NN[tt + 1] and NN[tt] usages
}
plot (1:(ttMax + 1), NN,
xlab = "time",
ylab = "Population size",
col = "blue",
lty = 2,
type = "l")
return(NN)
}
install.packages(plotly)
install.packages("plotly")
library(plotly)
plot_lu(x = r,
y = K,
z = data.vec,
type = "contour")
plot_ly(x = r,
y = K,
z = data.vec,
type = "contour")
head(data.vec)
data.vec <- matrix(NA, nrow=length(K), ncol=length(r)) # initialize empty vector with 5 row 11 col to store data
for (ii in 1:length(r)){ # ii refers to slot of a value in 1:lengt(r) vector
for (jj in 1:length(K)){ # jj refers
output <- rickerFun(n, ttMax, r = r[ii], K = K[jj]) # output for discrete logistic func at constant n and ttMax, but changing r and K parameters
data.vec[jj, ii] <- output[ttMax] # store values collected from model based on the changing r and K parameters at ttMax = 10
}
}
data.vec
plot_ly(x = r,
y = K,
z = data.vec,
type = "contour")
plot_ly(x = r,
y = K,
z = data.vec,
xlab = "growth rate (r)",
ylab = "carrying capacity (K)",
type = "contour")
?plot.ly
?plot_ly
plot_ly(x = r,
y = K,
z = data.vec,
xaxis = list(title = "growth rate (r)"),
yaxis = list(title = "carrying capacity (K)"),
type = "contour")
xaxis = list(title = "growth rate (r)"),
yaxis = list(title = "carrying capacity (K)"))
plot_ly(x = r,
y = K,
z = data.vec,
type = "contour"
scene = list(
xaxis = list(title = "growth rate (r)"),
yaxis = list(title = "carrying capacity (K)")))
plot_ly(x = r,
y = K,
z = data.vec,
type = "contour",
scene = list(
xaxis = list(title = "growth rate (r)"),
yaxis = list(title = "carrying capacity (K)")))
getwd()
setwd("/Users/BenjaminHa/Box Sync/RBootcamp/RBootcamp")
snpsDataFrame = read.table('hapmap_CEU_r23a_chr2_ld-2.txt', header=TRUE) # load data
phenoDataFrame = read.table('pheno.sim.2014-2.txt', header=TRUE) # load data
snps = as.matrix(snpsDataFrame) # convert dataframe into a matrix
chisq.test(x = snps,
y = NULL,
correct = TRUE,
p = rep(1/length(x),length(x)),
rescale.p = FALSE,
simulate.p.value = FALSE,
B = 2000)
compute_chisquare=function(x){
freq=sum(x,na.rm=TRUE)/(2.0*sum(!is.na(x)))
cnt0=sum(x==0,na.rm=TRUE)
cnt1=sum(x==1,na.rm=TRUE)
cnt2=sum(x==2,na.rm=TRUE)
obscnts=c(cnt0,cnt1,cnt2)
#print(obscnts)
n=sum(obscnts)
expcnts=c((1-freq)^2,2*freq*(1-freq),freq^2)*n
chisq=sum((obscnts-expcnts)^2/expcnts)
return(chisq)
}
chisqs = apply(snps,1,compute_chisquare) # code works
pvals = pchisq(chisqs,1,lower.tail=FALSE) # worked, since only referring to chisqs vector
num_pval <- length(pvals)
num_pval # quantity of SNPs tested
exp_pvals <- rep(NA, 1, 4014) # empty vector with 1 row, 4014 col to store data
for(ii in 1:length(pvals)){
exp_pvals[ii] <- ii / num_pval
}
head(exp_pvals)
sort_pval <- sort(exp_pvals, decreasing = TRUE)
head(exp_pvals) # not in decreasing order?
sort_pval <- sort(exp_pvals)
head(exp_pvals) # not in decreasing order?
sort_pval <- sort(pvals)
head(sort_pvals) # not in decreasing order?
sort_pval <- sort(pvals)
head(sort_pvals) # not in decreasing order?
head(sort_pval) # not in decreasing order?
log_sort_pvals <- -log10(sort_pval)
log_exp_pvals <- -log10(exp_pval)
log_exp_pvals <- -log10(exp_pvals)
qqplot(log_exp_pvals, log_sort_pval,
xlab = "-log10(expected P-value)",
ylab = "-log10(observed P-value")
log_sort_pval <- -log10(sort_pval)
log_exp_pvals <- -log10(exp_pvals)
qqplot(log_exp_pvals, log_sort_pval,
xlab = "-log10(expected P-value)",
ylab = "-log10(observed P-value")
abline(a = 0, # a = y intercept
b = 1,
col = "seafoam green") # b = slope
abline(a = 0, # a = y intercept
b = 1,
col = "seaform") # b = slope
abline(a = 0, # a = y intercept
b = 1,
col = "seafoam") # b = slope
abline(a = 0, # a = y intercept
b = 1,
col = "forest green") # b = slope
abline(a = 0, # a = y intercept
b = 1, # b = slope
col = "ocean green")
abline(a = 0, # a = y intercept
b = 1, # b = slope
col = "forest green",
lwd = 5)
abline(a = 0, # a = y intercept
b = 1, # b = slope
col = "forest green",
lwd = 3)
qqplot(log_exp_pvals, log_sort_pval,
xlab = "-log10(expected P-value)",
ylab = "-log10(observed P-value")
abline(a = 0, # a = y intercept
b = 1, # b = slope
col = "forest green",
lwd = 3)
phenoDataFrame = read.table('pheno.sim.2014-2.txt', header=TRUE)
pheno.data = as.matrix(phenoDataFrame)
zz = as.matrix(phenoDataFrame)
quantile(zz,0.25)
quantile(zz)
pdf(file="Phenotype_density.pdf", width=6,height=6)
par(mfrow=c(1,1), mar=c(4, 4, 3, 2)) #sets plotting area and margins
plot(density(zz),
col = 2,
lwd = 4,
xlab = "Value",
xlim = c(3,31),
main = "Phenotype density plot")
plot(density(zz),
col = 2,
lwd = 4,
xlab = "Value",
main = "Phenotype density plot")
dev.off()
plot(density(zz),
col = 2,
lwd = 4,
xlab = "Value",
main = "Phenotype density plot")
abline(quantile(zz,0.25),col='black')
abline(quantile(zz,0.75),col='black')
abline(v=quantile(zz,0.25),col='black')
abline(v=quantile(zz,0.75),col='black')
pdf(file="Phenotype_density.pdf", width=6,height=6)
par(mfrow=c(1,1), mar=c(4, 4, 3, 2)) #sets plotting area and margins
abline(v=quantile(zz,0.25),col='black') # v = veritcal line
plot(density(zz),
col = 2,
lwd = 4,
xlab = "Value",
main = "Phenotype density plot")
abline(v=quantile(zz,0.25),col='black') # v = veritcal line
abline(v=quantile(zz,0.75),col='black') # can do h = horizontal if needed
dev.off()
